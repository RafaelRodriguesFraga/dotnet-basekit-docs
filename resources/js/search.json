[[{"l":"Welcome to DotnetBaseKit"},{"l":"Introduction","p":["A comprehensive package designed to streamline the development process by providing pre-built components and architecture layers. DotnetBaseKit aims to simplify your workflow and enhance your productivity."]},{"i":"what-is-dotnetbasekit","l":"What is DotnetBaseKit?","p":["DotnetBaseKit is a collection of components organized into different layers, each serving a specific purpose in the software development. By using these components, developers can focus on building core features and business logic without the need to reinvent the wheel for common functionalities."]},{"l":"Components Overview","p":["All of the components are using dotnet 6.0","DotnetBaseKit.Components.Api: Provides API-related functionalities and abstractions for building RESTful services such as customized HTTP Responses.","DotnetBaseKit.Components.Application: It is intended to be inherited by other service application classes to promote code reusability and maintain a consistent approach to handling notifications and related functionalities. It has Pagination classes as well.","DotnetBaseKit.Components.Domain.Sql: Defines domain entities, value objects, and domain logic for SQL Databases (MySQL, SQL Server and Postgres in this version) promoting a clean approach.","DotnetBaseKit.Components.Domain.MongoDb: Defines domain logic for MongoDB promoting a clean approach.","DotnetBaseKit.Components.Infra.Sql: Provides infrastructure components for SQL databases interactions, such as repositories and database context management.","DotnetBaseKit.Components.Infra.MongoDb: Offers infrastructure components for interacting with MongoDB databases, including repositories and data access abstractions.","DotnetBaseKit.Components.Shared: Contains shared utilities, extensions, and helper classes used across different layers of the application."]},{"l":"Inspiration","p":["This package was based on Optsol.Components.Service. The whole set of components ( DotnetBaseKit.Components.Api, DotnetBaseKit.Components.Application, DotnetBaseKit.Components.Domain.MongoDb, DotnetBaseKit.Components.Domain.Sql, DotnetBaseKit.Components.Infra.MongoDb, DotnetBaseKit.Components.Infra.Sql, DotnetBaseKit.Components.Shared) is a basekit that was developed to make things a little bit easier for some people (and for learning purposes too)","Ready to dive into DotnetBaseKit? Check out our comprehensive documentation to learn how to integrate and utilize each component effectively in your .NET projects. Whether you're a seasoned developer or just getting started, we've got you covered with detailed guides, tutorials, and examples."]}],[{"l":"Components","p":["Welcome to the DotnetBaseKit Components section! This documentation provides an overview of the various components included in DotnetBaseKit, each designed to streamline and enhance specific aspects of .NET application development."]},{"l":"Overview","p":["DotnetBaseKit offer a comprehensive set of tools and functionalities to cover different layers of application architecture, including API development, application logic, domain modeling, and infrastructure management. Whether you're a beginner or an experienced developer, these components aim to simplify the development process and improve overall code quality."]},{"l":"Getting Started","p":["To get started, simply select a component from the list below (or in the menu on the left) to learn more about its features, installation instructions and examples. Whether you're building a simple web API or a complex application, DotnetBaseKit Components provide the essential building blocks to help you succeed.","Explore each component to discover how DotnetBaseKit can help you build better .NET applications. Let's dive in!"]}],[{"l":"Api Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Api package provides common functionality for WebApi Applications. It has ApiControllerBase that extends the ControllerBase class from Microsoft.AspNetCore.Mvc and encapsulates common response creation and handling logic."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:","Now, you have to add add the dependency that contains Responses and Notifications. Feel free to choose either the Program.cs approach or Startup.cs approach."]},{"l":"Usage","p":["With the dependencies added, you're ready to use it like below:","In this example, a TestService is called from the Application Layer. It accepts a TestApiViewModel object as a parameter, which represents the data to be inserted. It asynchronously calls the CreateAsync method of the ITestApiServiceApplication to perform the insertion. Upon successful, it returns a Created response using the ResponseCreated method previously mentioned."]}],[{"l":"Application Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Application is part of the DotnetBaseKit architecture, designed to provide a foundational structure for various service applications. It is intended to be inherited by other service application classes to promote code reusability and maintain a consistent approach to handling notifications and related functionalities such as pagination."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console","Now, you have to add the dependency that contains Pagination and Notifications. Feel free to choose either the Program.cs approach or Startup.cs approach."]},{"l":"Usage","p":["The primary purpose of the BaseServiceApplication class is to serve as a base class for other service application components. By inheriting from this class, developers can take advantage of its notification handling capabilities and maintain a consistent approach to managing notifications across the application.","With the dependencies added, you're ready to use it like below. You need to derive your service from BaseServiceApplication:","In this package there's a PaginationResponse class. You can see how to use here:","Go to Pagination","In practice, developers can create new service applications by inheriting from the BaseServiceApplication class and implementing the necessary business logic specific to their use case. The constructor ensures that each service application instance has access to a shared NotificationContext instance for handling notifications."]}],[{"i":"domainsql-layer","l":"Domain.Sql Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Domain.Sql part of the DotnetBaseKit architecture, designed to facilitate data management within SQL domains. It offers foundational structures for entities, DTOs, and repositories, aiming to streamline database interactions and maintain consistency across SQL-related functionalities. By adhering to the principles of separation of concerns and repository pattern, this layer promotes code organization, and reusability in SQL-related operations within the application's domain."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:"]},{"l":"Usage","p":["The primary purpose of the BaseEntity and BaseDto classes is to serve as foundational structures for entities and DTOs within the SQL domain of the application. By inheriting from these classes, developers can benefit from their validation and notification handling capabilities, ensuring a consistent approach to managing entities and DTOs across SQL-related functionalities.","For example, consider a scenario where we have an entity named Product representing products in an e-commerce application. We can define the Product entity as follows:","In this example, the Product class inherits from BaseEntity and implements its Validate() method to perform custom validation logic specific to the Product.","Similarly, consider a DTO named ProductDto representing product data transferred between layers of the application. We can define the ProductDto class as follows:","In this example, the ProductDto class inherits from BaseDto and implements its Validate() method to perform custom validation logic specific to the ProductDto.","By utilizing the BaseEntity and BaseDto classes in this manner, developers can ensure consistent validation and notification handling within the SQL domain of the application.","Go to Validations"]},{"l":"Repository Pattern","p":["The DotnetBaseKit.Components.Domain.Sql also provides interfaces for read and write repositories, IBaseReadRepository and IBaseWriteRepository. These interfaces define the methods required for data access operations, adhering to the repository pattern. This pattern helps in encapsulating the data access logic and promotes a cleaner separation of concerns for SQL Databases.","Create a Write / Read Repository Interface:","You can see the fully usage of the repository in Infra.Sql or in the Fully Usage Example"]}],[{"i":"domainmongodb-layer","l":"Domain.MongoDb Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Domain.MongoDb part of the DotnetBaseKit architecture, designed to facilitate data management within MongoDb. It offers foundational structures for entities, DTOs, and repositories, aiming to streamline database interactions and maintain consistency across MongoDB functionalities. By adhering to the principles of separation of concerns and repository pattern, this layer promotes code organization, and reusability in MOngoDB operations within the application's domain."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:"]},{"l":"Usage","p":["The primary purpose of the BaseEntity and BaseDto classes is to serve as foundational structures for entities and DTOs within the SQL domain of the application. By inheriting from these classes, developers can benefit from their validation and notification handling capabilities, ensuring a consistent approach to managing entities and DTOs across SQL-related functionalities.","For example, consider a scenario where we have an entity named Product representing products in an e-commerce application. We can define the Product entity as follows:","In this example, the Product class inherits from BaseEntity and implements its Validate() method to perform custom validation logic specific to the Product.","Similarly, consider a DTO named ProductDto representing product data transferred between layers of the application. We can define the ProductDto class as follows:","In this example, the ProductDto class inherits from BaseDto and implements its Validate() method to perform custom validation logic specific to the ProductDto.","By utilizing the BaseEntity and BaseDto classes in this manner, developers can ensure consistent validation and notification handling within the SQL domain of the application.","Go to Validations"]},{"l":"Repository Pattern","p":["The DotnetBaseKit.Components.Domain.MongoDB also provides interfaces for read and write repositories, IBaseReadRepository and IBaseWriteRepository. These interfaces define the methods required for data access operations, adhering to the repository pattern. This pattern helps in encapsulating the data access logic and promotes a cleaner separation of concerns for MongoDB.","Create a Write / Read Repository Interface:","PS: Do not confuse IBaseWriteRepository from Domain.Sql with IBaseWriteRepository from Domain.MongoDb. IBaseWriteRepository from Domain.Sql is from DotnetBaseKit.Components.Domain.Sql.Repositories.Base namespace and IBaseWriteRepository from Domain.MongoDb is from DotnetBaseKit.Components.Domain.MongoDb.Repositories.Base namespace. In future releases this will be fixed too for clear understanding.","You can see the fully usage of the repository in Infra.MongoDB or in the Fully Usage Example for MongoDB"]}],[{"i":"infrasql-layer","l":"Infra.Sql Layer","p":["Overview","The DotnetBaseKit.Components.Infra.Sq layer is a crucial part of the DotnetBaseKit architecture, designed to handle the data access logic for SQL databases. It provides a base context for Entity Framework Core, along with repository implementations for standard CRUD operations. This layer promotes the separation of concerns by encapsulating data access logic and offering reusable components for managing SQL database interactions."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:","Now, you have to add the dependency that contains write and read repositories. Feel free to choose either the Program.cs approach or Startup.cs approach."]},{"l":"DbContext Base Class","p":["The BaseContext class serves as a foundational DbContext for Entity Framework Core, providing basic configurations and constructors."]},{"l":"Usage","p":["The primary purpose of the BaseContext and the repository classes is to provide a standardized approach to data access in SQL databases. By utilizing these classes, developers can ensure consistent data management practices across the application.","Configure your DbContext:","You have to add modelBuilder.IgnoreNotification(), otherwise it will throw an error. In future releases this will be fixed. For fully usage of the Infra.Sql see the Fully Usage Example or Database Configuration.","Create a Write/Read Repository:","As you can see, you have to define an entity class that inherits from BaseEntity. Also you have to define an interface that extends IBaseWriteRepository/ IBaseReadRepository from the Domain Layer."]},{"l":"Usage in Dependency Injection","p":["To use the your repository in your application, register it in the dependency injection container. This ensures that the repository can be injected into services or controllers as needed.","Register your extension method on Program.cs or Startup.cs:","By following the structure provided, developers can effectively utilize the Infra.Sql layer to manage data access in SQL databases, ensuring consistency and maintainability across their applications."]}],[{"i":"inframongodb-layer","l":"Infra.MongoDb Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Infra.MongoDb is a part of the DotnetBaseKit architecture, designed to facilitate data management within MongoDB domains. It provides essential configurations and utilities for interacting with MongoDB databases, aiming to streamline database operations and maintain consistency across MongoDB-related functionalities."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:","Now, you have to add the dependency that contains write and read repositories. Feel free to choose either the Program.cs approach or Startup.cs approach."]},{"l":"Usage","p":["The primary purpose is to manage MongoDB and provide access to the database. Developers can configure MongoDB connections and perform database operations with the IMongoSettings interface and MongoSettings class. To see the configuration, go to MongoDB Configuration.","With the database configured, you can use the Infra.MongoDb component.","Just like the Infra.Sql, create a Write/Read Repository class:","Just like Infra.Sql you have to define an entity class that inherits from BaseEntity. Also you have to define an interface that extends IBaseWriteRepository/ IBaseReadRepository from the Domain Layer."]},{"l":"Usage in Dependency Injection","p":["To use the your repository in your application, register it in the dependency injection container. This ensures that the repository can be injected into services or controllers as needed.","Register your extension method on Program.cs or Startup.cs:","By following the structure provided, developers can effectively utilize the Infra.MongoDb layer to manage data access in MongoDb, ensuring consistency and maintainability across their applications."]}],[{"l":"Shared Layer"},{"l":"Overview","p":["The DotnetBaseKit.Components.Shared contains shared functionalities used across different parts of the application. Among these functionalities, the classes related to notifications stand out, providing mechanisms to handle notification messages and errors consistently throughout the application."]},{"l":"Installation","p":["Install this package via dotnet CLI or Package Manager Console:"]},{"l":"Usage","p":["This package is used together with the Application Layer in Service Application classes and Domain Layer in Entity / DTO classes","To see how to use Validations and Notifications, go to Validations section."]}],[{"l":"Configuration","p":["Welcome to the DotnetBaseKit Configuration section! This documentation provides an overview of how to set up and configure your application to use different databases. red to your specific requirements."]},{"l":"Overview","p":["DotnetBaseKit supports various database systems and offers flexible configuration options to cater to different needs. This section covers configuration for PostgreSQL, MySQL, SQL Server, and MongoDB, providing detailed instructions on how to set up each database"]},{"l":"Getting Started","p":["To get started, select a configuration topic from the list below (or in the menu on the left) to learn more about its settings, usage, and examples. Whether you're setting up a relational database or a NoSQL database like MongoDB, this section will guide you through the necessary steps.","Explore each topic to ensure your DotnetBaseKit application is configured correctly and optimized for your chosen database and logging requirements. Let's dive in!"]}],[{"l":"SQL Database Configuration"},{"l":"SQL Database Configuration","p":["The following appsettings.json sample includes all possible configuration options.","appsettings.json","After creating your Database Context ( see here) and mapping your database using Fluent API here, you can configure your appsettings.json as follows to support multiple databases:"]},{"l":"Detailed Configuration","p":["DotnetBaseKit offers support for PostgreSQL, MySQL, and SQL Server in this version. You can choose any of these databases by setting the SelectedDatabase property to Postgres, MySql, or SqlServer. Each database has its own connection string property as described below:"]},{"l":"PostgreSQL Configuration","p":["To use PostgreSQL, set SelectedDatabase to Postgres and provide the connection details under PostgresConnection."]},{"l":"MySQL Configuration","p":["To use MySQL, set SelectedDatabase to MySql and provide the connection details under MySqlConnection."]},{"l":"SQL Server Configuration","p":["To use SQL Server, set SelectedDatabase to SqlServer and provide the connection details under SqlServerConnection.","You can switch between the databases by changing the value of SelectedDatabase to either Postgres, MySql, or SqlServer as needed. Each setting will ensure that the correct connection string is used for your selected database."]}],[{"l":"MongoDB Database Configuration","p":["For MongoDB, you do not need to create a DbContext. Instead, you can configure your connection settings directly in the appsettings.json file by adding the MongoSettings section:","This configuration is all you need to connect to your MongoDB database. Adjust the DatabaseName and ConnectionString as necessary to match your MongoDB setup."]}],[{"l":"Full Appsettings Configuration","p":["Here you can see all of the configuration of appsettings.json:"]}],[{"l":"How to Use","p":["Welcome to the DotnetBaseKit How to Use section! This documentation provides an overview of how to use the various parts of the components included in DotnetBaseKit. You`ll learn how to use our Responses, Notiifications, Paginations, Validations and many more."]},{"l":"Getting Started","p":["To get started, simply select a part from the list below (or in the menu on the left) to learn more about its features and examples.","Explore each component to discover how DotnetBaseKit can help you build better .NET applications. Let's dive in!"]}],[{"l":"Responses"},{"l":"Overview","p":["These response methods are part of the DotnetBaseKit.Components.Api library. For detailed information on installation and usage, please refer to the Api in Components Section.","DotnetBaseKit.Components.Api offers a suite of methods designed to enhance the readability and structure of your API responses, including CreateResponse, ResponseCreated(), ResponseOk()(and others variations), and ResponseBadRequest(). These methods simplify the process of generating consistent and meaningful HTTP responses across your application."]},{"l":"Constructors","p":["The ApiControllerBase class provides a single constructor that accepts an IResponseFactory parameter. This constructor is used to inject an instance of the response factory, which is responsible for creating API responses. Example usage:","Inherit you Controller from ApiControllerBase."]},{"l":"Methods"},{"i":"createresponse","l":"CreateResponse()","p":["This method creates a basic API response using the injected response factory. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, an Ok response is returned with the response object.","Here’s an example of how to implement this in an Controller:","If there are no errors, the response will look like this:","If something goes wrong, the response will include the error details (these errors comes from the notifications):"]},{"i":"responseoktdatatdata-result","l":"ResponseOkTData(TData result)","p":["This method creates an API response with a single data object of type TData. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, an Ok response is returned with the response object.","Here’s an example of how to implement this in an ASP.NET Core controller:","In this example, the GetByIdAsync() method is called from a service, and the result is passed to the ResponseOk method.","If there are no errors, the response will look like this:","If something goes wrong, the response will include the error details (this error comes from the notifications):"]},{"i":"responseoktdataienumerabletdata-result","l":"ResponseOkTData(IEnumerableTData result)","p":["This method creates an API response with a collection of data objects of type TData. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, an Ok response is returned with the response object.","Here's an example of how to implement this in an Controller:","In this example, the GetAllAsync method is called from a service, and the result is passed to the ResponseOk method.","If there are no errors, the response will look like this:","If no data is present, the response will contain an empty array:"]},{"i":"responseoktdatapaginationresponsetdata-searchresult","l":"ResponseOkTData(PaginationResponseTData searchResult)","p":["This method creates an API response with a pagination result of type PaginationResponseTData. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, an Ok response is returned with the response object paginated.","Here’s an example of how to implement this in an Controller:","In this example, the GetAllPaginatedAsync method is called from a service, and the result is passed to the ResponseOk method.","If there are no errors, the response will look like this:"]},{"i":"responsecreatedtdatatdata-result","l":"ResponseCreatedTData(TData result)","p":["This method creates an API response for a successful resource creation operation. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, a Created response (HTTP 201) is returned with the response object.","Here’s an example of how to implement this in an Controller:","In this example, the CreateAsync() method is called from a service, and the result is passed to the ResponseCreated method.","If there are no errors, the response will look like this:","If something goes wrong, the response will include the error details (this error comes from the notifications):"]},{"i":"responsecreated","l":"ResponseCreated()","p":["This method creates a basic API response for a successful resource creation operation. It returns an IActionResult representing the HTTP response. If the response's Success property is false, a BadRequest response is returned. Otherwise, a Created response (HTTP 201) is returned with the response object.","Here’s an example of how to implement this in an Controller:","In this example, the CreateAsync() method is called from a service like the other above. The difference is that you don't pass anything to the ResponseCreated method.","If there are no errors, the response will look like this:","If something goes wrong, the response will include the error details (this error comes from the notifications):"]},{"i":"responsebadrequesttdatatdata-result","l":"ResponseBadRequestTData(TData result)","p":["This method creates a BadRequest response with the provided data object. It returns an IActionResult representing the HTTP Response BadRequest (400).","This is used to indicate that an error has occurred. The result can contain any JSON object of the specific error types mentioned above."]}],[{"l":"Pagination"},{"l":"Class Overview","p":["The PaginationResponse class within the DotnetBaseKit.Components.Application.Pagination namespace is a component designed to handle pagination-related responses in the DotnetBaseKit application. It implements the IPaginationResponseTData interface and is designed to be a versatile response structure that contains pagination-related information along with a collection of data."]},{"l":"Usage","p":["Developers can use this class when implementing methods that return paginated data. By utilizing the PaginationResponse class, developers can ensure consistent and predictable responses that include the data collection, current page number, total pages, and total record count.","The following method is used in DotnetBaseKit to retrieve paginated data. It returns a tuple with the result set and the total record count:","You can use this method in your ServiceApplication classes. First, in your interface, create a method like this:","Then, implement the method like this:","If there are no errors, the response will look like this:","This Pagination is only available to relational databases in this version. MongoDB Pagination will be added in the future."]}],[{"l":"Validations","p":["Validation ensures that the data being processed by your application adheres to predefined rules, helping to maintain data integrity and prevent errors. Implementing validation can catch issues early in the workflow, providing immediate feedback to users and developers when data does not meet the required criteria.","To get started with validation, you need to install the FluentValidation package. This package provides a fluent interface for building strongly-typed validation rules. Remember to install it in your Domain Layer."]},{"l":"Creating a Validator for Your DTO","p":["Here's an example of how to create a validation class for a DTO using FluentValidation:","For more information on FluentValidation, you can see the official documentation here"]},{"l":"Using the Validation Class","p":["You can use your validation class inside the Validate() method, along with the AddNotification() method:"]},{"l":"Implementing Validation in Service Application Methods","p":["Here's how you can use the validated DTO in your ServiceApplication methods:","When the YourDto data is validated and an error occurs, the Validate() method will flag the DTO as invalid. The validation errors defined in YourDtoContract will be added to the notification context.","In your API requests, if any of these errors occur, the response will look like this:","This setup ensures that your application handles data validation consistently and provides clear feedback when validation rules are not met, enhancing the robustness and user experience of your application."]}],[{"i":"database-mapping--config","l":"Database Mapping / Config","p":["There are many ways to perform database mapping in .NET. In Dotnet Basekit, the Fluent API approach is used, with database mapping configurations located in the Infra layer.","When mapping an entity to a database, if you do not specify a column name for your entity attributes or table, EF Core will default to using double quotes around the names during migration. For example: You choose an Entity to map to a database. If you dont choose a column name for your entities attributes or table, EF Core after execute a migration will put the name in double quotes. It would be like this:","To avoid this, explicitly choose names for your columns and tables, as demonstrated above."]},{"l":"Important Notes","p":["1. Ignored Properties: In this version of BaseKit, you must ignore the properties Notifications, Invalid, and Valid in every entity to prevent errors. This will be fixed in future updates.","2. Naming Recommendations: We recommend using lowercase and snake_case for your fields, especially id and created_at(inherited from BaseEntity)."]},{"l":"Explanation","p":["In this version of the BaseKit you have to ignore these first three properties in every single entity ( Notifications, Invalid and Valid`) or otherwise will throw an error. This will be fixed soon.","The other thing is that we recommend in this version to put your fields in lowercase and snake_case, mainly id and created_at(they come from BaseEntity)."]},{"l":"FluentAPI Methods","p":["To make a field required, use the IsRequired() method.","To specify a column name, use the HasColumnName(name) method.","To set a maximum length for a field, use the HasMaxLength(number) method.","To define a column type, use the HasColumnType(type) method.","To specify a table name, use the ToTable(table_name) method.","To see more of FluentAPI, see the official docummentation here;"]},{"l":"Using your Mapping","p":["After configuring all of the fields, you can use your mapping in the OnModelCreating() method in your DbContext:","Note: Some people refer to database mapping as Configuration, while others call it Map. In this example, we use the term Configuration. Feel free to use the term that you like."]}],[{"l":"Migrations"},{"l":"Overview","p":["Migrations are a way to keep the database schema in sync with the application's data model. They allow you to incrementally apply schema changes to your database, making it easier to evolve your database structure over time while preserving the data and share among developers."]},{"l":"Instalation","p":["To use migrations, you'll need to install the EF Core CLI tool or package. This should be installed in the Api layer of your project.","Now you're ready to use Migrations."]},{"l":"Usage","p":["Before creating a migration, ensure that your DbContext, Entity, Configurations/Database Mapping, and appsettings.json are properly configured to avoid any errors."]},{"l":"Creating a Migration","p":["To create a migration, use:","Replace your_infra_project with the path to your infra project. For example:","dotnet ef migrations add migration's name -p ../MyApi.Infra","If executes successfully, a Migrations folder will be created in your Infra project containing the new migration."]},{"l":"Migration Methods"},{"l":"Up","p":["The Up method defines the operations to apply the changes to the database schema. It includes all the fields that you specified in your configuration/mapping."]},{"l":"Down","p":["The Down method defines the operations to revert the changes applied by the Up method. This method removes the updates from the database, rolling back the changes."]},{"l":"Applying Migrations","p":["To apply the migration, use:","If executes successfully, you will have a new database with the updated schema."]}],[{"l":"Full Project Usage","p":["Coming soon..."]}]]